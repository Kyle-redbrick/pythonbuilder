/** 학생 평가 항목 리스트
 * decomposition:  분해
 * pattern (recognition) : 패턴 인식
 * abstraction : 추상화
 * algorithm : 알고리즘
 * programming : 프로그래밍
 * ex) 1-1 차시 항목: 분해, 평가 별 한개 : CURRICULUM_PYTHON_EVALUATION_LIST[1][1].decomposition[1]
 */
export const CURRICULUM_PYTHON_EVALUATION_LIST = {
  0: {
    // 무료체험
    1: {
      decomposition: {
        1: "파이와 이선이 해결해야 하는 문제를 파악하는 데 어려움이 있다.",
        2: "파이와 이선이 해결해야 하는 문제를 파악할 수 있다.",
        3: "파이와 이선이 해결해야 하는 문제를 체계적으로 파악할 수 있다.",
      },
      pattern: {
        1: "인공위성의 이름을 알아내기 위해 반복해서 확인해야 하는 조건이 무엇인지 설명하는 데 어려움이 있다.",
        2: "인공위성의 이름을 알아내기 위해 반복해서 확인해야 하는 조건이 무엇인지 설명할 수 있다.",
        3: "인공위성의 이름을 알아내기 위해 반복해서 확인해야 하는 조건이 무엇인지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "인공위성의 이름을 알아내기 위해 확인해야 하는 조건을 if 문으로 표현하는 데 어려움이 있다.",
        2: "인공위성의 이름을 알아내기 위해 확인해야 하는 조건을 if 문으로 표현할 수 있다.",
        3: "인공위성의 이름을 알아내기 위해 확인해야 하는 조건을 if 문으로 능숙하게 표현할 수 있다.",
      },
      algorithm: {
        1: "같은 알고리즘으로 인공위성을 찾기 위한 세 개의 다른 문제를 해결하는 데 어려움이 있다.",
        2: "같은 알고리즘으로 인공위성을 찾기 위한 세 개의 다른 문제를 해결할 수 있다.",
        3: "같은 알고리즘으로 인공위성을 찾기 위한 세 개의 다른 문제를 능숙하게 해결할 수 있다.",
      },
      programming: {
        1: "for, if 문을 이용해 조건을 충족하는 경우 실행되는 반복문을 코딩하는 데 어려움이 있다.",
        2: "for, if 문을 이용해 조건을 충족하는 경우 실행되는 반복문을 코딩할 수 있다.",
        3: "for, if 문을 이용해 조건을 충족하는 경우 실행되는 반복문을 능숙하게 코딩할 수 있다.",
      },
    },
  }, // END 무료체험
  1: {
    1: {
      decomposition: {
        1: "인공위성 비밀번호를 찾기 위한 해결 과정을 나누는 데 어려움이 있다.",
        2: "인공위성 비밀번호를 찾기 위한 해결 과정을 나눌 수 있다",
        3: "인공위성 비밀번호를 찾기 위한 해결 과정을 체계적으로 나눌 수 있다",
      },
      pattern: {
        1: "사건을 해결하기 위해 필요한 단서를 수집하는 데 어려움이 있다.",
        2: "사건을 해결하기 위해 필요한 단서를 수집할 수 있다",
        3: "사건을 해결하기 위해 필요한 단서를 체계적으로 수집할 수 있다",
      },
      abstraction: {
        1: "숫자 데이터 자료형의 종류에 따라 다르게 표현하는 데 어려움이 있다.",
        2: "숫자 데이터 자료형의 종류에 따라 다르게 표현할 수 있다",
        3: "숫자 데이터 자료형의 종류에 따라 다르게 체계적으로 표현할 수 있다",
      },
      algorithm: {
        1: "속력과 원의 둘레를 구하는 공식 알고리즘을 이해하는 데 어려움이 있다.",
        2: "속력과 원의 둘레를 구하는 공식 알고리즘을 이해할 수 있다",
        3: "속력과 원의 둘레를 구하는 공식 알고리즘을 능숙하게 이해할 수 있다.",
      },
      programming: {
        1: "산술연산자 기호와 변수를 사용하여 연산 프로그램을 만드는 데 어려움이 있다.",
        2: "산술연산자 기호와 변수를 사용하여 연산 프로그램을 만들 수 있다",
        3: "산술연산자 기호와 변수를 능숙하게 사용하여 연산 프로그램을 만들 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "비밀 작전 날짜를 추적하기 위한 해결 과정을 나누는 데 어려움이 있다.",
        2: "비밀 작전 날짜를 추적하기 위한 해결 과정을 나눌 수 있다.",
        3: "비밀 작전 날짜를 추적하기 위한 해결 과정을 체계적으로 나눌 수 있다.",
      },
      pattern: {
        1: "문자열 데이터 속에서 특수 문자 기호를 찾아내는 데 어려움이 있다.",
        2: "문자열 데이터 속에서 특수 문자 기호를 찾아낼 수 있다.",
        3: "문자열 데이터 속에서 특수 문자 기호를 체계적으로 찾아낼 수 있다.",
      },
      abstraction: {
        1: "문자열 데이터 자료형의 형태를 구분하는 데 어려움이 있다.",
        2: "문자열 데이터 자료형의 형태를 구분할 수 있다.",
        3: "문자열 데이터 자료형의 형태를 체계적으로 구분할 수 있다.",
      },
      algorithm: {
        1: "원하는 문자열 데이터를 추출하기 위한 알고리즘을 생각하는 데 어려움이 있다.",
        2: "원하는 문자열 데이터를 추출하기 위한 알고리즘을 생각할 수 있다",
        3: "원하는 문자열 데이터를 추출하기 위한 알고리즘을 능숙하게 생각할 수 있다.",
      },
      programming: {
        1: "문자열 인덱싱과 슬라이싱에 대해 알고 필요한 데이터를 추출하는 데 어려움이 있다.",
        2: "문자열 인덱싱과 슬라이싱에 대해 알고 필요한 데이터를 추출할 수 있다.",
        3: "문자열 인덱싱과 슬라이싱에 대해 알고 능숙하게 필요한 데이터를 추출할 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "비밀 작전 장소를 추적하기 위한 해결 과정을 나누는 데 어려움이 있다.",
        2: "비밀 작전 장소를 추적하기 위한 해결 과정을 나눌 수 있다.",
        3: "비밀 작전 장소를 추적하기 위한 해결 과정을 체계적으로 나눌 수 있다.",
      },
      pattern: {
        1: "문자열 데이터에서 장소를 나타내는 단어를 찾는 데 어려움이 있다.",
        2: "문자열 데이터에서 장소를 나타내는 단어를 찾을 수 있다.",
        3: "문자열 데이터에서 장소를 나타내는 단어를 체계적으로 찾을 수 있다.",
      },
      abstraction: {
        1: "문자열 데이터의 순서를 뒤집는 방법을 찾아내는 데 어려움이 있다.",
        2: "문자열 데이터의 순서를 뒤집는 방법을 찾아낼 수 있다.",
        3: "문자열 데이터의 순서를 뒤집는 방법을 체계적으로 찾아낼 수 있다.",
      },
      algorithm: {
        1: "손상된 데이터를 분석하여 힌트 데이터를 찾는 알고리즘을 생각하는 데 어려움이 있다. ",
        2: "손상된 데이터를 분석하여 힌트 데이터를 찾는 알고리즘을 생각할 수 있다.",
        3: "손상된 데이터를 분석하여 힌트 데이터를 찾는 알고리즘을 능숙하게 생각할 수 있다.",
      },
      programming: {
        1: "문자열 데이터를 리스트 데이터로 변환하는 데 어려움이 있다.",
        2: "문자열 데이터를 리스트 데이터로 변환할 수 있다.",
        3: "문자열 데이터를 리스트 데이터로 능숙하게 변환할 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "헤이그 도시를 사수하기 위한 해결 과정을 나누는 데 어려움이 있다.",
        2: "헤이그 도시를 사수하기 위한 해결 과정을 나눌 수 있다.",
        3: "헤이그 도시를 사수하기 위한 해결 과정을 체계적으로 나눌 수 있다.",
      },
      pattern: {
        1: "시청 건물의 용도를 파악하고 짝수 층의 위험물 감지 센서의 상태를 알아내는 데 어려움이 있다.",
        2: "시청 건물의 용도를 파악하고 짝수 층의 위험물 감지 센서의 상태를 알아낼 수 있다.",
        3: "시청 건물의 용도를 파악하고 짝수 층의 위험물 감지 센서의 상태를 체계적인 논리에 따라 알아낼 수 있다.",
      },
      abstraction: {
        1: "빌더 버그 조직이 특정 층을 타깃으로 잡은 이유를 설명하는 데 어려움이 있다",
        2: "빌더 버그 조직이 특정 층을 타깃으로 잡은 이유를 설명할 수 있다.",
        3: "빌더 버그 조직이 특정 층을 타깃으로 잡은 이유를 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "시청에 설치된 폭발물을 찾기 위한 조건을 적용하는 알고리즘을 생각하는 데 어려움이 있다.",
        2: "시청에 설치된 폭발물을 찾기 위한 조건을 적용하는 알고리즘을 생각할 수 있다",
        3: "시청에 설치된 폭발물을 찾기 위한 조건을 적용하는 알고리즘을 능숙하게 생각할 수 있다",
      },
      programming: {
        1: "조건 및 반복 제어문을 사용하여 폭발물이 설치된 층을 찾아내는 데 어려움이 있다.",
        2: "조건 및 반복 제어문을 사용하여 폭발물이 설치된 층을 찾아낼 수 있다.",
        3: "조건 및 반복 제어문을 사용하여 능숙하게 폭발물이 설치된 층을 찾아낼 수 있다.",
      },
    },
  },
  2: {
    1: {
      decomposition: {
        1: "총면적을 구하는 과정을 작은 문제로 나누는 데 어려움이 있다.",
        2: "총면적을 구하는 과정을 작은 문제로 나눌 수 있다.",
        3: "총면적을 구하는 과정을 작은 문제로 체계적으로 나눌 수 있다.",
      },
      pattern: {
        1: "총면적을 구하는 데에 어떤 과정이 반복되는지 설명하는 데 어려움이 있다.",
        2: "총면적을 구하는 데에 어떤 과정이 반복되는지 설명할 수 있다.",
        3: "총면적을 구하는 데에 어떤 과정이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "호수 면적을 변수를 통해서 비교하는 데 어려움이 있다.",
        2: "호수 면적을 변수를 통해서 비교할 수 있다.",
        3: "호수 면적을 변수를 통해서 체계적으로 비교할 수 있다.",
      },
      algorithm: {
        1: "호수 면적이 특정한 수 이하일 경우 더해나가는 과정을 나열하는 데 어려움이 있다.",
        2: "호수 면적이 특정한 수 이하일 경우 더해나가는 과정을 나열할 수 있다.",
        3: "호수 면적이 특정한 수 이하일 경우 더해나가는 과정을 체계적으로 나열할 수 있다.",
      },
      programming: {
        1: "append를 사용하여 원하는 요소를 리스트에 삽입하는 데 어려움이 있다.",
        2: "append를 사용하여 원하는 요소를 리스트에 삽입할 수 있다.",
        3: "append를 능숙하게 사용하여 원하는 요소를 리스트에 삽입할 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "폭탄 해체를 위해서 매뉴얼을 작성하는 과정을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "폭탄 해체를 위해서 매뉴얼을 작성하는 과정을 작은 문제로 나누어 설명할 수 있다.",
        3: "폭탄 해체를 위해서 매뉴얼을 작성하는 과정을 작은 문제로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "폭탄 해체 메뉴얼을 작성하는 데에 어떤 작업이 반복되는지 인식하는 데 어려움이 있다.",
        2: "폭탄 해체 메뉴얼을 작성하는 데에 어떤 작업이 반복되는지 인식할 수 있다. ",
        3: "폭탄 해체 메뉴얼을 작성하는 데에 어떤 작업이 반복되는지 인식하고 능숙하게 설명할 수 있다.",
      },
      abstraction: {
        1: "인덱스를 이용하여 리스트 안의 원하는 요소를 선택하는 데 어려움이 있다.",
        2: "인덱스를 이용하여 리스트 안의 원하는 요소를 선택할 수 있다.",
        3: "인덱스를 이용하여 리스트 안의 원하는 요소를 능숙하게 선택할 수 있다.",
      },
      algorithm: {
        1: "작성한 폭탄 해체 메뉴얼의 논리 구성을 이해하는 데 어려움이 있다.",
        2: "작성한 폭탄 해체 메뉴얼의 논리 구성을 이해할 수 있다.",
        3: "작성한 폭탄 해체 메뉴얼의 논리 구성을 이해하고 설명할 수 있다.",
      },
      programming: {
        1: "if, elif 명령어를 사용하여 여러 가지 조건을 가진 코드를 작성하는 데 어려움이 있다.",
        2: "if, elif 명령어를 시용하여 여러 가지 조건을 가진 코드를 작성할 수 있다.",
        3: "if, elif 명령어를 능숙하게 시용하여 여러 가지 조건을 가진 코드를 작성할 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "없어진 파일의 구간, 시간대를 확인하는 과정을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "없어진 파일의 구간, 시간대를 확인하는 과정을 작은 문제로 나누어 설명할 수 있다.",
        3: "없어진 파일의 구간, 시간대를 확인하는 과정을 작은 문제로 능숙하게 설명할 수 있다.",
      },
      pattern: {
        1: "없어진 파일 구간과 파일의 시간대를 확인하며 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "없어진 파일 구간과 파일의 시간대를 확인하며 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "없어진 파일 구간과 파일의 시간대를 확인하며 어떤 작업이 반복되는지 능숙하게 설명할 수 있다.",
      },
      abstraction: {
        1: "2차원 리스트 안의 원하는 요소를 인덱스를 이용하여 선택하는 데 어려움이 있다.",
        2: "2차원 리스트 안의 원하는 요소를 인덱스를 이용하여 선택할 수 있다.",
        3: "2차원 리스트 안의 원하는 요소를 인덱스를 능숙하게 이용하여 선택할 수 있다.",
      },
      algorithm: {
        1: "파일이 없어진 구간을 확인하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "파일이 없어진 구간을 확인하는 과정을 순서대로 나열할 수 있다.",
        3: "파일이 없어진 구간을 확인하는 과정을 순서대로 능숙하게 나열할 수 있다.",
      },
      programming: {
        1: "while 명령어를 사용하여 반복적인 작업을 실행하는 데 어려움이 있다.",
        2: "while 명령어를 사용하여 반복적인 작업을 실행할 수 있다.",
        3: "while 명령어를 능숙하게 사용하여 반복적인 작업을 실행할 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "2진수 리스트를 문자 행으로 나타내는 과정을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "2진수 리스트를 문자 행으로 나타내는 과정을 작은 문제로 나누어 설명할 수 있다.",
        3: "2진수 리스트를 문자 행으로 나타내는 과정을 작은 문제로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "결과물을 문자 행으로 출력하는 과정에서 줄 바꿈 제거를 포함하여 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "결과물을 문자 행으로 출력하는 과정에서 줄 바꿈 제거를 포함하여 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "결과물을 문자 행으로 출력하는 과정에서 줄 바꿈 제거를 포함하여 어떤 작업이 반복되는지 능숙하게 설명할 수 있다.",
      },
      abstraction: {
        1: "문자열과 숫자열의 차이를 이해하고 요구되는 자료로 변환하는 데 어려움이 있다.",
        2: "문자열과 숫자열의 차이를 이해하고 요구되는 자료로 변환할 수 있다.",
        3: "문자열과 숫자열의 차이를 이해하고 요구되는 자료로 능숙하게 변환할 수 있다.",
      },
      algorithm: {
        1: "2진수 리스트를 문자행으로 두 조건을 중첩해 변경하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "2진수 리스트를 문자행으로 두 조건을 중첩해 변경하는 과정을 순서대로 나열할 수 있다.",
        3: "2진수 리스트를 문자행으로 두 조건을 중첩해 변경하는 과정을 능숙하게 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "for _ in 이중 반복문을 사용하여 반복 조건을 중첩하는 데 어려움이 있다.",
        2: "for _ in 이중 반복문을 사용하여 반복 조건을 중첩할 수 있다.",
        3: "for _ in 이중 반복문을 능숙하게 사용하여 반복 조건을 중첩할 수 있다.",
      },
    },
  },
  3: {
    1: {
      decomposition: {
        1: "순서도를 사용하여 로그를 정리하는 과정을 나타내는 데 어려움이 있다.",
        2: "순서도를 사용하여 로그를 정리하는 과정을 나타낼 수 있다.",
        3: "순서도를 사용하여 능숙하게 로그를 정리하는 과정을 나타낼 수 있다.",
      },
      pattern: {
        1: "로그를 종류와 종목을 기준으로 정리하면서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "로그를 종류와 종목을 기준으로 정리하면서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "로그를 종류와 종목을 기준으로 정리하면서 어떤 작업이 반복되는지 능숙하게 설명할 수 있다.",
      },
      abstraction: {
        1: "지우고자 하는 데이터를 딕셔너리의 개념을 활용하여 특정하는 데 어려움이 있다.",
        2: "지우고자 하는 데이터를 딕셔너리의 개념을 활용하여 특정할 수 있다.",
        3: "지우고자 하는 데이터를 딕셔너리의 개념을 활용하여 능숙하게 특정할 수 있다.",
      },
      algorithm: {
        1: "가격을 기준으로 데이터의 목록을 추출하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "가격을 기준으로 데이터의 목록을 추출하는 과정을 순서대로 나열할 수 있다.",
        3: "가격을 기준으로 데이터의 목록을 추출하는 과정을 능숙하게 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "딕셔너리 구조 데이터와 get 명령어를 사용하여 특정 값을 가진 데이터를 선택하는 데 어려움이 있다.",
        2: "딕셔너리 구조 데이터와 get 명령어를 사용하여 특정 값을 가진 데이터를 선택할 수 있다.",
        3: "딕셔너리 구조 데이터와 get 명령어를 능숙하게 사용하여 특정 값을 가진 데이터를 선택할 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "FPN 리스트를 출력하는 과정을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "FPN 리스트를 출력하는 과정을 작은 문제로 나누어 설명할 수 있다.",
        3: "FPN 리스트를 출력하는 과정을 작은 문제로 능숙하게 나누어 설명할 수 있다.",
      },
      pattern: {
        1: "FPN 리스트를 찾는 과정과 IP 위치를 추적하는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "FPN 리스트를 찾는 과정과 IP 위치를 추적하는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "FPN 리스트를 찾는 과정과 IP 위치를 추적하는 과정에서 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "찾는 데이터의 기준을 Key 개념을 이용하여 특정하는 데 어려움이 있다.",
        2: "찾는 데이터의 기준을 Key 개념을 이용하여 특정할 수 있다.",
        3: "찾는 데이터의 기준을 Key 개념을 이용하여 능숙하게 특정할 수 있다",
      },
      algorithm: {
        1: "IP 주소의 앞글자를 기준으로 국가를 추적하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "IP 주소의 앞글자를 기준으로 국가를 추적하는 과정을 순서대로 나열할 수 있다.",
        3: "IP 주소의 앞글자를 기준으로 국가를 추적하는 과정을 능숙하게 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "딕셔너리 자료형과 key 값을 사용하여 특정한 자료를 추출하는 데 어려움이 있다.",
        2: "딕셔너리 자료형과 key 값을 사용하여 특정한 자료를 추출할 수 있다.",
        3: "딕셔너리 자료형과 key 값을 능숙하게 사용하여 특정한 자료를 추출할 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "모스부호가 있는 거래 내역만 추출하는 과정을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "모스부호가 있는 거래 내역만 추출하는 과정을 작은 문제로 나누어 설명할 수 있다.",
        3: "모스부호가 있는 거래 내역만 추출하는 과정을 작은 문제로 나누어 능숙하게 설명할 수 있다.",
      },
      pattern: {
        1: "모스부호를 추출하는 코드의 for 반복문 안에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "모스부호를 추출하는 코드의 for 반복문 안에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "모스부호를 추출하는 코드의 for 반복문 안에서 어떤 작업이 반복되는지 능숙하게 설명할 수 있다.",
      },
      abstraction: {
        1: "모스부호 사전을 만들 때 모스부호와 알파벳을 key와 value에 빗대어 설명하는 데 어려움이 있다.",
        2: "모스부호 사전을 만들 때 모스부호와 알파벳을 key와 value에 빗대어 설명할 수 있다.",
        3: "모스부호 사전을 만들 때 모스부호와 알파벳을 key와 value에 빗대어 능숙하게 설명할 수 있다.",
      },
      algorithm: {
        1: "모스부호를 해독하여 결과를 출력하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "모스부호를 해독하여 결과를 출력하는 과정을 순서대로 나열할 수 있다.",
        3: "모스부호를 해독하여 결과를 출력하는 과정을 능숙하게 순서대로 나열할 수 있다. ",
      },
      programming: {
        1: "zip 명령어를 사용하여 두 개의 데이터를 합쳐 딕셔너리 구조로 만드는 데 어려움이 있다.",
        2: "zip 명령어를 사용하여 두 개의 데이터를 합쳐 딕셔너리 구조로 만들 수 있다.",
        3: "zip 명령어를 능숙하게 사용하여 두 개의 데이터를 합쳐 딕셔너리 구조로 만들 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "MONA 프로젝트에 참여한 기관을 확인하는 과정을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "MONA 프로젝트에 참여한 기관을 확인하는 과정을 작은 문제로 나누어 설명할 수 있다.",
        3: "MONA 프로젝트에 참여한 기관을 확인하는 과정을 작은 문제로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "차집합, 교집합, 합집합을 구하는 과정에서 각각 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "차집합, 교집합, 합집합을 구하는 과정에서 각각 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "차집합, 교집합, 합집합을 구하는 과정에서 각각 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "구하려는 요소의 모음을 집합으로 나타내는 데 어려움이 있다.",
        2: "구하려는 요소의 모음을 집합으로 나타낼 수 있다.",
        3: "구하려는 요소의 모음을 집합으로 능숙하게 나타낼 수 있다.",
      },
      algorithm: {
        1: "MONA 프로젝트에 참여한 기관을 확인하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "MONA 프로젝트에 참여한 기관을 확인하는 과정을 순서대로 나열할 수 있다.",
        3: "MONA 프로젝트에 참여한 기관을 확인하는 과정을 능숙하게 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "set 명령어와 적절한 연산자를 사용하여 합집합, 교집합, 차집합을 나타내는 데 어려움이 있다.",
        2: "set 명령어와 적절한 연산자를 사용하여 합집합, 교집합, 차집합을 나타낼 수 있다.",
        3: "set 명령어와 적절한 연산자를 능숙하게 사용하여 합집합, 교집합, 차집합을 나타낼 수 있다.",
      },
    },
  },
  4: {
    1: {
      decomposition: {
        1: "모스부호가 포함된 거래 내역을 구하는 과정을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "모스부호가 포함된 거래 내역을 구하는 과정을 작은 문제로 나누어 설명할 수 있다.",
        3: "모스부호가 포함된 거래 내역을 구하는 과정을 작은 문제로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "거래내역을 추출하는 함수에 포함될 반복되는 작업이 무엇인지 인식하는 데 어려움이 있다.",
        2: "거래내역을 추출하는 함수에 포함될 반복되는 작업이 무엇인지 인식할 수 있다.",
        3: "거래내역을 추출하는 함수에 포함될 반복되는 작업이 무엇인지 인식하고 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "ATM 기기 번호를 추출하는 과정에서 None의 개념을 이해하고 조건문에 활용하는 데 어려움이 있다.",
        2: "ATM 기기 번호를 추출하는 과정에서 None의 개념을 이해하고 조건문에 활용할 수 있다.",
        3: "ATM 기기 번호를 추출하는 과정에서 None의 개념을 이해하고 조건문에 능숙하게 활용할 수 있다.",
      },
      algorithm: {
        1: "안면 인식 데이터를 분석해 범인을 가려내는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "안면 인식 데이터를 분석해 범인을 가려내는 과정을 순서대로 나열할 수 있다.",
        3: "안면 인식 데이터를 분석해 범인을 가려내는 과정을 순서대로 능숙하게 나열할 수 있다.",
      },
      programming: {
        1: "def (): 문을 적절하게 사용하는 데 어려움이 있다.",
        2: "def (): 문을 사용하여 함수를 정의하고 호출할 수 있다.",
        3: "def (): 문을 능숙하게 사용하여 함수를 정의하고 호출할 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "트랜스포지션 암호를 해독하는 과정을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "트랜스포지션 암호를 해독하는 과정을 작은 문제로 나누어 설명할 수 있다.",
        3: "트랜스포지션 암호를 해독하는 과정을 작은 문제로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "트랜스포지션 암호를 해독하는 과정에서 함수에 포함될 반복되는 과정이 무엇인지 인식하는 데 어려움이 있다.",
        2: "트랜스포지션 암호를 해독하는 과정에서 함수에 포함될 반복되는 과정이 무엇인지 인식할 수 있다.",
        3: "트랜스포지션 암호를 해독하는 과정에서 함수에 포함될 반복되는 과정이 무엇인지 인식하고 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "필름을 정렬하기 위해서 필름의 순서를 번호로 대치하는 데 어려움이 있다.",
        2: "필름을 정렬하기 위해서 필름의 순서를 번호로 대치할 수 있다. ",
        3: "필름을 정렬하기 위해서 필름의 순서를 번호로 능숙하게 대치할 수 있다.",
      },
      algorithm: {
        1: "필름을 순서대로 정렬하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "필름을 순서대로 정렬하는 과정을 순서대로 나열할 수 있다.",
        3: "필름을 순서대로 정렬하는 과정을 순서대로 능숙하게 나열할 수 있다.",
      },
      programming: {
        1: "sort 함수를 사용하여 리스트 안의 요소를 오름차순으로 정렬하는 데 어려움이 있다.",
        2: "sort 함수를 사용하여 리스트 안의 요소를 오름차순으로 정렬할 수 있다.",
        3: "sort 함수를 능숙하게 사용하여 리스트 안의 요소를 오름차순으로 정렬할 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "루트를 탐색하는 방법을 작은 과정으로 나누어 설명하는 데 어려움이 있다.",
        2: "루트를 탐색하는 방법을 작은 과정으로 나누어 설명할 수 있다.",
        3: "루트를 탐색하는 방법을 작은 과정으로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "루트를 탐색할 때 방향을 확인하기 위해서 반복되는 과정이 무엇인지 인식하는 데 어려움이 있다.",
        2: "루트를 탐색할 때 방향을 확인하기 위해서 반복되는 과정이 무엇인지 인식할 수 있다.",
        3: "루트를 탐색할 때 방향을 확인하기 위해서 반복되는 과정이 무엇인지 인식하고 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "진행 방향을 2차원 리스트 요소로 치환하는 데 어려움이 있다.",
        2: "진행 방향을 2차원 리스트 요소로 치환할 수 있다.",
        3: "진행 방향을 2차원 리스트 요소로 능숙하게 치환할 수 있다.",
      },
      algorithm: {
        1: "루트를 탐색하여 탈출구를 찾는 전체 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "루트를 탐색하여 탈출구를 찾는 전체 과정을 순서대로 나열할 수 있다.",
        3: "루트를 탐색하여 탈출구를 찾는 전체 과정을 순서대로 능숙하게 나열할 수 있다.",
      },
      programming: {
        1: "2차원 리스트의 인덱스 값을 사용하여 방향을 나타내는 데 어려움이 있다.",
        2: "2차원 리스트의 인덱스 값을 사용하여 방향을 나타낼 수 있다.",
        3: "2차원 리스트의 인덱스 값을 능숙하게 사용하여 방향을 나타낼 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "주어진 데이터 route의 각 요소가 의미하는 바를 설명하는 데 어려움이 있다.",
        2: "주어진 데이터 route의 각 요소가 의미하는 바를 설명할 수 있다",
        3: "주어진 데이터 route의 각 요소가 의미하는 바를 능숙하게 설명할 수 있다",
      },
      pattern: {
        1: "가능한 모든 경로를 알아낼 때 반복되는 작업에 무엇이 있는지 설명하는 데 어려움이 있다.",
        2: "가능한 모든 경로를 알아낼 때 반복되는 작업에 무엇이 있는지 설명할 수 있다.",
        3: "가능한 모든 경로를 알아낼 때 반복되는 작업에 무엇이 있는지 능숙하게 설명할 수 있다.",
      },
      abstraction: {
        1: "가장 적은 시간이 소요되는 경로를 최솟값으로 치환하는 데 어려움이 있다.",
        2: "가장 적은 시간이 소요되는 경로를 최솟값으로 치환할 수 있다.",
        3: "가장 적은 시간이 소요되는 경로를 최솟값으로 능숙하게 치환할 수 있다.",
      },
      algorithm: {
        1: "가능한 모든 경로를 파악하는 전체 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "가능한 모든 경로를 파악하는 전체 과정을 순서대로 나열할 수 있다.",
        3: "가능한 모든 경로를 파악하는 전체 과정을 순서대로 능숙하게 나열할 수 있다.",
      },
      programming: {
        1: "get,pop 명령어를 사용하여 리스트 내에서 원하는 요소를 제거하는 데 어려움이 있다.",
        2: "get,pop 명령어를 사용하여 리스트 내에서 원하는 요소를 제거할 수 있다.",
        3: "get,pop 명령어를 능숙하게 사용하여 리스트 내에서 원하는 요소를 제거할 수 있다.",
      },
    },
  },
  5: {
    1: {
      decomposition: {
        1: "심장 박동수를 분석하기 위해 구해야 하는 요소(평균값, 차이가 있는 구간 등)를 설명하는 데 어려움이 있다.",
        2: "심장 박동수를 분석하기 위해 구해야 하는 요소(평균값, 차이가 있는 구간 등)를 설명할 수 있다.",
        3: "심장 박동수를 분석하기 위해 구해야 하는 요소(평균값, 차이가 있는 구간 등)를 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "이차원 리스트의 평균값을 구하는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "이차원 리스트의 평균값을 구하는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "이차원 리스트의 평균값을 구하는 과정에서 어떤 작업이 반복되는지 체계적으로 설명할 수 있다",
      },
      abstraction: {
        1: "편차가 생긴 구간을 이차원 리스트를 이용하여 찾는 데 어려움이 있다.",
        2: "편차가 생긴 구간을 이차원 리스트를 이용하여 찾을 수 있다.",
        3: "편차가 생긴 구간을 이차원 리스트를 이용하여 능숙하게 찾을 수 있다.",
      },
      algorithm: {
        1: "심장 박동수를 분석하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "심장 박동수를 분석하는 과정을 순서대로 나열할 수 있다.",
        3: "심장 박동수를 분석하는 과정을 순서대로 능숙하게 나열할 수 있다.",
      },
      programming: {
        1: "mean, round, abs 명령어를 사용하여 평균 구하기, 반올림하기, 절댓값 구하기 등의 작업을 하는 데 어려움이 있다.",
        2: "mean, round, abs 명령어를 사용하여 평균 구하기, 반올림하기, 절댓값 구하기 등의 작업을 할 수 있다.",
        3: "mean, round, abs 명령어를 능숙하게 사용하여 평균 구하기, 반올림하기, 절댓값 구하기 등의 작업을 할 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "데이터를 반전시키는 과정을 작은 문제로 나누어서 설명하는 데 어려움이 있다.",
        2: "데이터를 반전시키는 과정을 작은 문제로 나누어서 설명할 수 있다.",
        3: "데이터를 반전시키는 과정을 작은 문제로 나누어서 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "좌우 반전의 기준을 정하는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "좌우 반전의 기준을 정하는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "좌우 반전의 기준을 정하는 과정에서 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "이차원 리스트의 요소를 변수에 할당하여 변환하는 개념을 이해하는 데 어려움이 있다.",
        2: "이차원 리스트의 요소를 변수에 할당하여 변환하는 개념을 이해할 수 있다.",
        3: "이차원 리스트의 요소를 변수에 할당하여 변환하는 개념을 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "반전 과정을 교체 연산 알고리즘을 통해 이해할 수 있고 실행되는 순서를 나열하는 데 어려움이 있다.",
        2: "반전 과정을 교체 연산 알고리즘을 통해 이해할 수 있고 실행되는 순서를 나열할 수 있다.",
        3: "반전 과정을 교체 연산 알고리즘을 통해 이해할 수 있고 실행되는 순서를 체계적으로 나열할 수 있다.",
      },
      programming: {
        1: "range, len, 임시변수, 매개변수를 사용하여 데이터를 반전하는 데 어려움이 있다.",
        2: "range, len, 임시변수, 매개변수를 사용하여 데이터를 반전할 수 있다.",
        3: "range, len, 임시변수, 매개변수를 능숙하게 사용하여 데이터를 반전할 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "그림을 비교하는 방법을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "그림을 비교하는 방법을 작은 문제로 나누어 설명할 수 있다.",
        3: "그림을 비교하는 방법을 작은 문제로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "그림의 RGB 값을 비교할 때 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "그림의 RGB 값을 비교할 때 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "그림의 RGB 값을 비교할 때 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "명령어의 종합을 클래스의 개념으로 묶어 이해하는 데 어려움이 있다.",
        2: "명령어의 종합을 클래스의 개념으로 묶어 이해할 수 있다.",
        3: "명령어의 종합을 클래스의 개념으로 묶어 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "그림 픽셀 R 값을 해독하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "그림 픽셀 R 값을 해독하는 과정을 순서대로 나열할 수 있다.",
        3: "그림 픽셀 R 값을 해독하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "class를 완성하는 데 어려움이 있다.",
        2: "필요한 메소드를 입력하여 class를 완성할 수 있다.  ",
        3: "필요한 메소드를 입력하여 능숙하게 class를 완성할 수 있다.  ",
      },
    },
    4: {
      decomposition: {
        1: "그림을 해독하는 과정을 다양한 비트 연산 방식으로 나누어 설명하는 데 어려움이 있다.",
        2: "그림을 해독하는 과정을 다양한 비트 연산 방식으로 나누어 설명할 수 있다.",
        3: "그림을 해독하는 과정을 다양한 비트 연산 방식으로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "그림을 해독하는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "그림을 해독하는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "그림을 해독하는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
      },
      abstraction: {
        1: "비트 연산을 하고 난 후 결과를 좌표로 나타내는 원리를 이해하는 데 어려움이 있다.",
        2: "비트 연산을 하고 난 후 결과를 좌표로 나타내는 원리를 이해할 수 있다.",
        3: "비트 연산을 하고 난 후 결과를 좌표로 나타내는 원리를 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "그림을 해독하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "그림을 해독하는 과정을 순서대로 나열할 수 있다.",
        3: "그림을 해독하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "&, l, ^ 연산자를 사용하여 비트 연산을 수행하는 데 어려움이 있다.",
        2: "&, l, ^ 연산자를 사용하여 비트 연산을 수행할 수 있다.",
        3: "&, l, ^ 연산자를 능숙하게 사용하여 비트 연산을 수행할 수 있다.",
      },
    },
  },
  6: {
    1: {
      decomposition: {
        1: "요원과 비밀 통신을 하기 위해 필요한 과정을 작은 문제로 나누어 생각하는 데 어려움이 있다.",
        2: "요원과 비밀 통신을 하기 위해 필요한 과정을 작은 문제로 나누어 생각할 수 있다.",
        3: "요원과 비밀 통신을 하기 위해 필요한 과정을 작은 문제로 나누어 생각하고 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "서버 클래스를 통해 인스턴스를 생성하는 과정에서 어떤 작업이 반복되는지 인식하는 데 어려움이 있다.",
        2: "서버 클래스를 통해 인스턴스를 생성하는 과정에서 어떤 작업이 반복되는지 인식할 수 있다. ",
        3: "서버 클래스를 통해 인스턴스를 생성하는 과정에서 어떤 작업이 반복되는지 인식하고 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "새로운 무전기를 만드는 과정을 클래스의 개념을 이용하여 설명하는 데 어려움이 있다.",
        2: "새로운 무전기를 만드는 과정을 클래스의 개념을 이용하여 설명할 수 있다.",
        3: "새로운 무전기를 만드는 과정을 클래스의 개념을 이용하여 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "클래스를 이용해 인스턴스를 생성하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "클래스를 이용해 인스턴스를 생성하는 과정을 순서대로 나열할 수 있다.",
        3: "클래스를 이용해 인스턴스를 생성하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "클래스 객체 접근을 사용하여 필요한 값을 가져오는 데 어려움이 있다.",
        2: "클래스 객체 접근을 사용하여 필요한 값을 가져올 수 있다.",
        3: "클래스 객체 접근을 능숙하게 사용하여 필요한 값을 능숙하게 가져올 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "로봇에 필요한 기능을 추가하기 위해 필요한 기능을 작은 단위에서 설명하는 데 어려움이 있다.",
        2: "로봇에 필요한 기능을 추가하기 위해 필요한 기능을 작은 단위에서 설명할 수 있다.",
        3: "로봇에 필요한 기능을 추가하기 위해 필요한 기능을 작은 단위에서 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "로봇에 추가한 목소리를 찾는 메소드에서 어떤 과정이 반복되는지 설명하는 데 어려움이 있다.",
        2: "로봇에 추가한 목소리를 찾는 메소드에서 어떤 과정이 반복되는지 설명할 수 있다.",
        3: "로봇에 추가한 목소리를 찾는 메소드에서 어떤 과정이 반복되는지 체계적으로 설명할 수 있다",
      },
      abstraction: {
        1: "필요한 값을 찾기 위해서 클래스에서 어떤 메소드를 추가해야 하는지 설명하는 데 어려움이 있다.",
        2: "필요한 값을 찾기 위해서 클래스에서 어떤 메소드를 추가해야 하는지 설명할 수 있다.",
        3: "필요한 값을 찾기 위해서 클래스에서 어떤 메소드를 추가해야 하는지 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "클래스에 메소드를 추가하여 필요한 값을 가져오는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "클래스에 메소드를 추가하여 필요한 값을 가져오는 과정을 순서대로 나열할 수 있다.",
        3: "클래스에 메소드를 추가하여 필요한 값을 가져오는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "클래스에 메소드를 추가하고 객체 접근을 사용하여 필요한 값을 찾는 데 어려움이 있다.",
        2: "클래스에 메소드를 추가하고 객체 접근을 사용하여 필요한 값을 찾을 수 있다.",
        3: "클래스에 메소드를 추가하고 객체 접근을 능숙하게 사용하여 필요한 값을 찾을 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "내려받은 이미지를 확인하기 위해 필요한 과정을 작은 단위에서 설명하는 데 어려움이 있다.",
        2: "내려받은 이미지를 확인하기 위해 필요한 과정을 작은 단위에서 설명할 수 있다.",
        3: "내려받은 이미지를 확인하기 위해 필요한 과정을 작은 단위에서 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "openCV와 모듈을 사용하는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "openCV와 모듈을 사용하는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "openCV와 모듈을 사용하는 과정에서 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "팽창의 개념을 픽셀값을 사용하여 설명하는 데 어려움이 있다.",
        2: "팽창의 개념을 픽셀값을 사용하여 설명할 수 있다.",
        3: "팽창의 개념을 픽셀값을 사용하여 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "이미지를 읽어 팽창시키는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "이미지를 읽어 팽창시키는 과정을 순서대로 나열할 수 있다.",
        3: "이미지를 읽어 팽창시키는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "openCV와 모듈의 사용 방법을 알고 사용하는 데 어려움이 있다.",
        2: "openCV와 모듈의 사용 방법을 알고 사용할 수 있다.",
        3: "openCV와 모듈의 사용 방법을 알고 능숙하게 사용할 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "해시의 구조를 키, 주소, 값으로 나누어 이해하는 데 어려움이 있다.",
        2: "해시의 구조를 키, 주소, 값으로 나누어 이해할 수 있다.",
        3: "해시의 구조를 키, 주소, 값으로 나누어 이해하고 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "주차타워의 비밀번호 및 주차 위치가 어떤 규칙으로 생성되는지 설명하는 데 어려움이 있다.",
        2: "주차타워의 비밀번호 및 주차 위치가 어떤 규칙으로 생성되는지 설명할 수 있다.",
        3: "주차타워의 비밀번호 및 주차 위치가 어떤 규칙으로 생성되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "해시의 개념을 이해하고 용도와 목적을 포함하여 설명하는 데 어려움이 있다.",
        2: "해시의 개념을 이해하고 용도와 목적을 포함하여 설명할 수 있다.",
        3: "해시의 개념을 이해하고 용도와 목적을 포함하여 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "주소 생성법과 충돌 처리를 포함하여 작성한 해시 함수의 처리 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "주소 생성법과 충돌 처리를 포함하여 작성한 해시 함수의 처리 과정을 순서대로 나열할 수 있다.",
        3: "주소 생성법과 충돌 처리를 포함하여 작성한 해시 함수의 처리 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "데이터 구조 해시를 함수로 구현하고 사용하는 데 어려움이 있다.",
        2: "데이터 구조 해시를 함수로 구현하고 사용할 수 있다.",
        3: "데이터 구조 해시를 함수로 구현하고 능숙하게 사용할 수 있다.",
      },
    },
  },
  7: {
    1: {
      decomposition: {
        1: "물류 센터까지 들어가는 방향을 나타내는 과정을 작은 단위에서 설명하는 데 어려움이 있다.",
        2: "물류 센터까지 들어가는 방향을 나타내는 과정을 작은 단위에서 설명할 수 있다.",
        3: "물류 센터까지 들어가는 방향을 나타내는 과정을 작은 단위에서 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "이차원 리스트의 값에 따라 방향을 지정하는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "이차원 리스트의 값에 따라 방향을 지정하는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "이차원 리스트의 값에 따라 방향을 지정하는 과정에서 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "스택의 개념과 특징을 이용해 로봇이 왔던 길을 되돌아가는 원리를 설명하는 데 어려움이 있다.",
        2: "스택의 개념과 특징을 이용해 로봇이 왔던 길을 되돌아가는 원리를 설명할 수 있다.",
        3: "스택의 개념과 특징을 이용해 로봇이 왔던 길을 되돌아가는 원리를 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "로봇이 왔던 방향을 거꾸로 출력하는 과정을 순차적으로 나열하는 데 어려움이 있다.",
        2: "로봇이 왔던 방향을 거꾸로 출력하는 과정을 순차적으로 나열할 수 있다.",
        3: "로봇이 왔던 방향을 거꾸로 출력하는 과정을 순차적으로 체계적으로 나열할 수 있다.",
      },
      programming: {
        1: "push, pop 명령어를 통해 스택 자료구조를 적절하게 다루는 데 어려움이 있다.",
        2: "push, pop 명령어를 통해 스택 자료구조를 다룰 수 있다.",
        3: "push, pop 명령어를 통해 스택 자료구조를 능숙하게 다룰 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "무기가 실린 컨테이너를 찾는 과정을 작은 단위에서 설명하는 데 어려움이 있다.",
        2: "무기가 실린 컨테이너를 찾는 과정을 작은 단위에서 설명할 수 있다.",
        3: "무기가 실린 컨테이너를 찾는 과정을 작은 단위에서 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "스택을 클래스로 구현할 때, 스택의 특징에 맞춰 어떤 메소드가 작성되는지 설명하는 데 어려움이 있다.",
        2: "스택을 클래스로 구현할 때, 스택의 특징에 맞춰 어떤 메소드가 작성되는지 설명할 수 있다.",
        3: "스택을 클래스로 구현할 때, 스택의 특징에 맞춰 어떤 메소드가 작성되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "추적하는 화물이 화물선에 옮겨지는 과정을 pop, push의 개념으로 설명하는 데 어려움이 있다.",
        2: "추적하는 화물이 화물선에 옮겨지는 과정을 pop, push의 개념으로 설명할 수 있다.",
        3: "추적하는 화물이 화물선에 옮겨지는 과정을 pop, push의 개념으로 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "화물선 운송 시뮬레이션이 작동하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "화물선 운송 시뮬레이션이 작동하는 과정을 순서대로 나열할 수 있다.",
        3: "화물선 운송 시뮬레이션이 작동하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "클래스를 사용하여 스택을 구현하는 데 어려움이 있다.",
        2: "클래스를 사용하여 스택을 구현할 수 있다.",
        3: "클래스를 능숙하게 사용하여 스택을 구현할 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "주어진 화물 운송 트럭 데이터가 어떤 요소들로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "주어진 화물 운송 트럭 데이터가 어떤 요소들로 이루어져 있는지 설명할 수 있다.",
        3: "주어진 화물 운송 트럭 데이터가 어떤 요소들로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "큐를 클래스로 구현할 때, 큐의 특징에 맞춰 어떤 메소드가 작성되는지 설명하는 데 어려움이 있다.",
        2: "큐를 클래스로 구현할 때, 큐의 특징에 맞춰 어떤 메소드가 작성되는지 설명할 수 있다.",
        3: "큐를 클래스로 구현할 때, 큐의 특징에 맞춰 어떤 메소드가 작성되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "화물이 화물 운송 트럭에 옮겨지는 과정을 enqueue, dequeue의 개념으로 설명하는 데 어려움이 있다.",
        2: "화물이 화물 운송 트럭에 옮겨지는 과정을 enqueue, dequeue의 개념으로 설명할 수 있다.",
        3: "화물이 화물 운송 트럭에 옮겨지는 과정을 enqueue, dequeue의 개념으로 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "화물 운송 시뮬레이션이 작동하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "화물 운송 시뮬레이션이 작동하는 과정을 순서대로 나열할 수 있다.",
        3: "화물 운송 시뮬레이션이 작동하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "클래스를 사용하여 큐를 구현하고, enqueue,dequeue 명령어를 사용하는 데 어려움이 있다.",
        2: "클래스를 사용하여 큐를 구현하고, enqueue,dequeue 명령어를 사용할 수 있다.",
        3: "클래스를 사용하여 큐를 구현하고, enqueue,dequeue 명령어를 체계적으로 사용할 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "화학식량을 구하는 과정을 작은 단위에서 설명하는 데 어려움이 있다.",
        2: "화학식량을 구하는 과정을 작은 단위에서 설명할 수 있다.",
        3: "화학식량을 구하는 과정을 작은 단위에서 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "화학식량을 구하는 함수를 구현하면서, 괄호, 글자, 숫자에 따라 어떤 작업이 필요한지 이해하는 데 어려움이 있다.",
        2: "화학식량을 구하는 함수를 구현하면서, 괄호, 글자, 숫자에 따라 어떤 작업이 필요한지 이해할 수 있다.",
        3: "화학식량을 구하는 함수를 구현하면서, 괄호, 글자, 숫자에 따라 어떤 작업이 필요한지 이해하고 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "화학식량을 계산할 때 자료구조형 스택이 사용되는 이유를 이해하는 데 어려움이 있다.",
        2: "화학식량을 계산할 때 자료구조형 스택이 사용되는 이유를 이해할 수 있다.",
        3: "화학식량을 계산할 때 자료구조형 스택이 사용되는 이유를 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "화학식량을 구하는 함수가 작동하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "화학식량을 구하는 함수가 작동하는 과정을 순서대로 나열할 수 있다.",
        3: "화학식량을 구하는 함수가 작동하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "스택 자료구조를 사용하여 후위 수식을 계산하는 데 어려움이 있다.",
        2: "스택 자료구조를 사용하여 후위 수식을 계산할 수 있다.",
        3: "스택 자료구조를 능숙하게 사용하여 후위 수식을 계산할 수 있다.",
      },
    },
  },
  8: {
    1: {
      decomposition: {
        1: "주어진 증인 주변 인물들의 통화 기록이 어떤 요소들로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "주어진 증인 주변 인물들의 통화 기록이 어떤 요소들로 이루어져 있는지 설명할 수 있다.",
        3: "주어진 증인 주변 인물들의 통화 기록이 어떤 요소들로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "그래프를 구현하는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "그래프를 구현하는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "그래프를 구현하는 과정에서 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "통화 기록이 가장 많은 사람을 찾기 위해 그래프 자료형을 사용하는 이유를 이해하는 데 어려움이 있다.",
        2: "통화 기록이 가장 많은 사람을 찾기 위해 그래프 자료형을 사용하는 이유를 이해할 수 있다.",
        3: "통화 기록이 가장 많은 사람을 찾기 위해 그래프 자료형을 사용하는 이유를 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "메소드 add_edge가 작동하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "메소드 add_edge가 작동하는 과정을 순서대로 나열할 수 있다.",
        3: "메소드 add_edge가 작동하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "그래프를 구현하고 노드와 간선을 추가하는 데 어려움이 있다.",
        2: "그래프를 구현하고 노드와 간선을 추가할 수 있다.",
        3: "그래프를 구현하고 노드와 간선을 능숙하게 추가할 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "인접 리스트의 구조를 딕셔너리와 리스트 단위에서 설명하는 데 어려움이 있다.",
        2: "인접 리스트의 구조를 딕셔너리와 리스트 단위에서 설명할 수 있다.",
        3: "인접 리스트의 구조를 딕셔너리와 리스트 단위에서 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "Angella와 연결된 사람을 찾는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "Angella와 연결된 사람을 찾는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "Angella와 연결된 사람을 찾는 과정에서 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "인접 리스트를 클래스로 구현할 때, 특징에 맞춰 어떤 메소드가 작성되는지 설명하는 데 어려움이 있다.",
        2: "인접 리스트를 클래스로 구현할 때, 특징에 맞춰 어떤 메소드가 작성되는지 설명할 수 있다.",
        3: "인접 리스트를 클래스로 구현할 때, 특징에 맞춰 어떤 메소드가 작성되는지 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "Angella와 연결된 사람을 찾는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "Angella와 연결된 사람을 찾는 과정을 순서대로 나열할 수 있다.",
        3: "Angella와 연결된 사람을 찾는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "인접 리스트 형태로 정리된 데이터에서 원하는 요소를 찾아내는 데 어려움이 있다.",
        2: "인접 리스트 형태로 정리된 데이터에서 원하는 요소를 찾아낼 수 있다.",
        3: "인접 리스트 형태로 정리된 데이터에서 능숙하게 원하는 요소를 찾아낼 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "증인이 지나간 IC를 찾는 과정을 작은 단위에서 설명하는 데 어려움이 있다.",
        2: "증인이 지나간 IC를 찾는 과정을 작은 단위에서 설명할 수 있다.",
        3: "증인이 지나간 IC를 찾는 과정을 작은 단위에서 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "증인이 지나간 IC를 찾는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "증인이 지나간 IC를 찾는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "증인이 지나간 IC를 찾는 과정에서 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "넓이 우선 탐색을 그래프의 개념을 통해서 이해하는 데 어려움이 있다.",
        2: "넓이 우선 탐색을 그래프의 개념을 통해서 이해할 수 있다.",
        3: "넓이 우선 탐색을 그래프의 개념을 통해서 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "넓이 우선 탐색 함수가 작동하는 과정을 순서대로 나열하는 데 어려움이 있다. ",
        2: "넓이 우선 탐색 함수가 작동하는 과정을 순서대로 나열할 수 있다.",
        3: "넓이 우선 탐색 함수가 작동하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "넓이 우선 탐색을 통해 자료구조형 그래프에서 원하는 요소를 찾는 데 어려움이 있다.",
        2: "넓이 우선 탐색을 통해 자료구조형 그래프에서 원하는 요소를 찾을 수 있다.",
        3: "넓이 우선 탐색을 통해 자료구조형 그래프에서 원하는 요소를 능숙하게 찾을 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "다익스트라 알고리즘을 작은 단계로 나누어 설명하는 데 어려움이 있다.",
        2: "다익스트라 알고리즘을 작은 단계로 나누어 설명할 수 있다.",
        3: "다익스트라 알고리즘을 작은 단계로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "다익스트라 알고리즘을 구현할 때 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "다익스트라 알고리즘을 구현할 때 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "다익스트라 알고리즘을 구현할 때 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "우선순위 큐가 구현한 다익스트라 알고리즘에서 어떻게 사용되는지 이해하는 데 어려움이 있다.",
        2: "우선순위 큐가 구현한 다익스트라 알고리즘에서 어떻게 사용되는지 이해할 수 있다.",
        3: "우선순위 큐가 구현한 다익스트라 알고리즘에서 어떻게 사용되는지 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "다익스트라 알고리즘이 작동하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "다익스트라 알고리즘이 작동하는 과정을 순서대로 나열할 수 있다.",
        3: "다익스트라 알고리즘이 작동하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "다익스트라 알고리즘을 통해 인접 그래프를 탐색하는 데 어려움이 있다.",
        2: "다익스트라 알고리즘을 통해 인접 그래프를 탐색하는 최단 단선 거리를 계산할 수 있다.",
        3: "다익스트라 알고리즘을 통해 능숙하게 인접 그래프를 탐색하는 최단 단선 거리를 계산할 수 있다.",
      },
    },
  },
  9: {
    1: {
      decomposition: {
        1: "최대공약수와 최대공배수를 구하는 과정을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "최대공약수와 최대공배수를 구하는 과정을 작은 문제로 나누어 설명할 수 있다.",
        3: "최대공약수와 최대공배수를 구하는 과정을 작은 문제로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "최대공약수를 재귀를 사용하지 않고 구현할 때 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "최대공약수를 재귀를 사용하지 않고 구현할 때 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "최대공약수를 재귀를 사용하지 않고 구현할 때 어떤 작업이 반복되는지 체계적으로 설명할 수 있다",
      },
      abstraction: {
        1: "최대공약수를 구하는 과정에서 재귀함수가 어떻게 사용되는지 이해하는 데 어려움이 있다.",
        2: "최대공약수를 구하는 과정에서 재귀함수가 어떻게 사용되는지 이해할 수 있다.",
        3: "최대공약수를 구하는 과정에서 재귀함수가 어떻게 사용되는지 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "재귀함수를 사용하여 최소공배수를 구하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "재귀함수를 사용하여 최소공배수를 구하는 과정을 순서대로 나열할 수 있다.",
        3: "재귀함수를 사용하여 최소공배수를 구하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "재귀함수를 사용하여 최대공약수와 최소공배수를 구하는 데 어려움이 있다.",
        2: "재귀함수를 사용하여 최대공약수와 최소공배수를 구할 수 있다.",
        3: "재귀함수를 능숙하게 사용하여 최대공약수와 최소공배수를 구할 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "회문을 찾아내는 방법을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "회문을 찾아내는 방법을 작은 문제로 나누어 설명할 수 있다",
        3: "회문을 찾아내는 방법을 작은 문제로 나누어 체계적으로 설명할 수 있다",
      },
      pattern: {
        1: "5글자로 이루어진 회문을 찾을 때 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "5글자로 이루어진 회문을 찾을 때 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "5글자로 이루어진 회문을 찾을 때 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "회문의 특징을 파악해 회문 판별 함수가 어떻게 작성되는지 이해하는 데 어려움이 있다.",
        2: "회문의 특징을 파악해 회문 판별 함수가 어떻게 작성되는지 이해할 수 있다.",
        3: "회문의 특징을 파악해 회문 판별 함수가 어떻게 작성되는지 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "길이가 21인 염기서열을 찾아내는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "길이가 21인 염기서열을 찾아내는 과정을 순서대로 나열할 수 있다.",
        3: "길이가 21인 염기서열을 찾아내는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "재귀함수를 사용하여 회문을 판별하는 데 어려움이 있다.",
        2: "재귀함수를 사용하여 회문을 판별할 수 있다.",
        3: "재귀함수를 능숙하게 사용하여 회문을 판별할 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "주어진 병원 조직도가 어떤 요소들로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "주어진 병원 조직도가 어떤 요소들로 이루어져 있는지 설명할 수 있다.",
        3: "주어진 병원 조직도가 어떤 요소들로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "트리에서 공통 조상을 찾는 과정에서 어떤 작업이 반복되는지 설명하는 데 어려움이 있다.",
        2: "트리에서 공통 조상을 찾는 과정에서 어떤 작업이 반복되는지 설명할 수 있다.",
        3: "트리에서 공통 조상을 찾는 과정에서 어떤 작업이 반복되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "조상의 개념을 통해 강제 종료 신호가 내려진 구역을 관리하는 부서를 설명하는 데 어려움이 있다.",
        2: "조상의 개념을 통해 강제 종료 신호가 내려진 구역을 관리하는 부서를 설명할 수 있다.",
        3: "조상의 개념을 통해 강제 종료 신호가 내려진 구역을 관리하는 부서를 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "공통 조상 찾기 알고리즘이 작동하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "공통 조상 찾기 알고리즘이 작동하는 과정을 순서대로 나열할 수 있다.",
        3: "공통 조상 찾기 알고리즘이 작동하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "공통 조상 찾기 알고리즘을 구현하고 트리 구조의 데이터에서 원하는 요소를 찾는 데 어려움이 있다.",
        2: "공통 조상 찾기 알고리즘을 구현하고 트리 구조의 데이터에서 원하는 요소를 찾을 수 있다.",
        3: "공통 조상 찾기 알고리즘을 구현하고 트리 구조의 데이터에서 원하는 요소를 능숙하게 찾을 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "없어진 샘플을 알아내는 방법을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "없어진 샘플을 알아내는 방법을 작은 문제로 나누어 설명할 수 있다.",
        3: "없어진 샘플을 알아내는 방법을 작은 문제로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "선택 정렬 알고리즘에서 어떤 과정이 반복되는지 이해하는 데 어려움이 있다.",
        2: "선택 정렬 알고리즘에서 어떤 과정이 반복되는지 이해할 수 있다.",
        3: "선택 정렬 알고리즘에서 어떤 과정이 반복되는지 이해하고 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "시간 복잡도의 개념을 이해하거나 설명하는 데 어려움이 있다.",
        2: "시간 복잡도의 개념을 이해하고 설명할 수 있다.",
        3: "시간 복잡도의 개념을 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "선택 정렬 알고리즘이 작동하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "선택 정렬 알고리즘이 작동하는 과정을 순서대로 나열할 수 있다",
        3: "선택 정렬 알고리즘이 작동하는 과정을 순서대로 능숙하게 나열할 수 있다.",
      },
      programming: {
        1: "선택정렬 알고리즘을 구현하고 데이터를 정렬하는 데 어려움이 있다",
        2: "선택정렬 알고리즘을 구현하고 데이터를 정렬할 수 있다.",
        3: "선택정렬 알고리즘을 구현하고 데이터를 능숙하게 정렬할 수 있다.",
      },
    },
  },
  10: {
    1: {
      decomposition: {
        1: "CCTV 설치 현황을 나타낸 데이터가 어떤 요소로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "CCTV 설치 현황을 나타낸 데이터가 어떤 요소로 이루어져 있는지 설명할 수 있다.",
        3: "CCTV 설치 현황을 나타낸 데이터가 어떤 요소로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "detect 함수를 보고 언제 감시 가능 구역으로 전환이 멈추는지 설명하는 데 어려움이 있다.",
        2: "detect 함수를 보고 언제 감시 가능 구역으로 전환이 멈추는지 설명할 수 있다.",
        3: "detect 함수를 보고 언제 감시 가능 구역으로 전환이 멈추는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "2차원 리스트를 좌표로 활용하는 방법을 이해하고 설명하는 데 어려움이 있다.",
        2: "2차원 리스트를 좌표로 활용하는 방법을 이해하고 설명할 수 있다.",
        3: "2차원 리스트를 좌표로 활용하는 방법을 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "의사코드 detect 내에서 카메라가 확인할 수 있는 방향에 따라 좌표를 조절하는 과정을 나열하는 데 어려움이 있다.",
        2: "의사코드 detect 내에서 카메라가 확인할 수 있는 방향에 따라 좌표를 조절하는 과정을 나열할 수 있다.  ",
        3: "의사코드 detect 내에서 카메라가 확인할 수 있는 방향에 따라 좌표를 조절하는 과정을 체계적으로 나열할 수 있다.  ",
      },
      programming: {
        1: "2차원 리스트의 인덱스와 조건문을 사용하여 원하는 요소에 접근하고 의사코드를 완성하는 데 어려움이 있다.",
        2: "2차원 리스트의 인덱스와 조건문을 사용하여 원하는 요소에 접근하고 의사코드를 완성할 수 있다.",
        3: "2차원 리스트의 인덱스와 조건문을 능숙하게 사용하여 원하는 요소에 접근하고 의사코드를 완성할 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "데이터를 보고 리스트마다 어떤 요소가 저장되어 있는지 설명하는 데 어려움이 있다.",
        2: "데이터를 보고 리스트마다 어떤 요소가 저장되어 있는지 설명할 수 있다.",
        3: "데이터를 보고 리스트마다 어떤 요소가 저장되어 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "isCounterclockwise 함수를 보고 방향에 따라 어떤 값을 리턴하는지 설명하는 데 어려움이 있다.",
        2: "isCounterclockwise 함수를 보고 방향에 따라 어떤 값을 리턴하는지 설명할 수 있다.",
        3: "isCounterclockwise 함수를 보고 방향에 따라 어떤 값을 리턴하는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "점이 회전해야 하는 방향을 반환 값으로 치환하여 이해하는 데 어려움이 있다.",
        2: "점이 회전해야 하는 방향을 반환 값으로 치환하여 이해할 수 있다.",
        3: "점이 회전해야 하는 방향을 반환 값으로 치환하여 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "볼록 껍질 다각형 알고리즘이 작동하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "볼록 껍질 다각형 알고리즘이 작동하는 과정을 순서대로 나열할 수 있다.",
        3: "볼록 껍질 다각형 알고리즘이 작동하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "스택을 사용하여 볼록 껍질 다각형 알고리즘을 구현하는 데 어려움이 있다.",
        2: "스택을 사용하여 볼록 껍질 다각형 알고리즘을 구현할 수 있다.",
        3: "스택을 사용하여 볼록 껍질 다각형 알고리즘을 능숙하게 구현할 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "오염 시뮬레이션이 작동하는 과정을 작은 단계로 나누어 설명하는 데 어려움이 있다.",
        2: "오염 시뮬레이션이 작동하는 과정을 작은 단계로 나누어 설명할 수 있다.",
        3: "오염 시뮬레이션이 작동하는 과정을 작은 단계로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "시뮬레이션 함수 infection을 보고 어떤 경우에 공간 (0)이 오염구역(3)으로 전환되는지 설명하는 데 어려움이 있다.",
        2: "시뮬레이션 함수 infection을 보고 어떤 경우에 공간 (0)이 오염구역(3)으로 전환되는지 설명할 수 있다.",
        3: "시뮬레이션 함수 infection을 보고 어떤 경우에 공간 (0)이 오염구역(3)으로 전환되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "재귀를 이용해 문제를 해결할 경우, 어떤 노드를 매개변수로 사용해야 하는지 설명하는 데 어려움이 있다.",
        2: "재귀를 이용해 문제를 해결할 경우, 어떤 노드를 매개변수로 사용해야 하는지 설명할 수 있다.",
        3: "재귀를 이용해 문제를 해결할 경우, 어떤 노드를 매개변수로 사용해야  하는지 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "깊이 우선 탐색 알고리즘이 작동하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "깊이 우선 탐색 알고리즘이 작동하는 과정을 순서대로 나열할 수 있다.",
        3: "깊이 우선 탐색 알고리즘이 작동하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "스택 혹은 재귀를 사용하여 깊이 우선 탐색 알고리즘을 구현하는 데 어려움이 있다.",
        2: "스택 혹은 재귀를 사용하여 깊이 우선 탐색 알고리즘을 구현할 수 있다.",
        3: "스택 혹은 재귀를 사용하여 깊이 우선 탐색 알고리즘을 능숙하게 구현할 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "find_robot 함수를 보고 어떤 요소로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "find_robot 함수를 보고 어떤 요소로 이루어져 있는지 설명할 수 있다.",
        3: "find_robot 함수를 보고 어떤 요소로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "코드를 작성하기 전 dist_data에서 모든 값이 어떻게 처리되어 있는지 설명하는 데 어려움이 있다.",
        2: "코드를 작성하기 전 dist_data에서 모든 값이 어떻게 처리되어 있는지 설명할 수 있다.",
        3: "코드를 작성하기 전 dist_data에서 모든 값이 어떻게 처리되어 있는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "넓이 우선 탐색 알고리즘과 깊이 우선 탐색 알고리즘의 차이점을 설명하는 데 어려움이 있다.",
        2: "넓이 우선 탐색 알고리즘과 깊이 우선 탐색 알고리즘의 차이점을 설명할 수 있다.",
        3: "넓이 우선 탐색 알고리즘과 깊이 우선 탐색 알고리즘의 차이점을 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "로봇의 이동 거리를 출력하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "로봇의 이동 거리를 출력하는 과정을 순서대로 나열할 수 있다.",
        3: "로봇의 이동 거리를 출력하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "2차원 배열의 인덱스와 넓이 우선 탐색 알고리즘을 사용하는 데 어려움이 있다.",
        2: "2차원 배열의 인덱스와 넓이 우선 탐색 알고리즘을 사용하여 최단 거리를 출력할 수 있다.",
        3: "2차원 배열의 인덱스와 넓이 우선 탐색 알고리즘을 능숙하게 사용하여 최단 거리를 출력할 수 있다.",
      },
    },
  },
  11: {
    1: {
      decomposition: {
        1: "범죄율을 계산하기 위해 필요한 작업을 작은 단계로 나누어 설명하는 데 어려움이 있다.",
        2: "범죄율을 계산하기 위해 필요한 작업을 작은 단계로 나누어 설명할 수 있다.",
        3: "범죄율을 계산하기 위해 필요한 작업을 작은 단계로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "도시 이름을 범죄 건수 순으로 나열했을 때 어떤 결과가 나오는지 설명하는 데 어려움이 있다.  (ex:인구수가 많으면 상위에 노출)",
        2: "도시 이름을 범죄 건수 순으로 나열했을 때 어떤 결과가 나오는지 설명할 수 있다. (ex:인구수가 많으면 상위에 노출)",
        3: "도시 이름을 범죄 건수 순으로 나열했을 때 어떤 결과가 나오는지 체계적으로 설명할 수 있다. (ex:인구수가 많으면 상위에 노출)",
      },
      abstraction: {
        1: "범죄율을 계산한 열을 추출하는 방법을 기존에 존재하는 자료를 사용해 설명하는 데 어려움이 있다.",
        2: "범죄율을 계산한 열을 추출하는 방법을 기존에 존재하는 자료를 사용해 설명할 수 있다.",
        3: "범죄율을 계산한 열을 추출하는 방법을 기존에 존재하는 자료를 사용해 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "cvs 파일을 표로 정리하고 범죄율을 데이터에 추가하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "cvs 파일을 표로 정리하고 범죄율을 데이터에 추가하는 과정을 순서대로 나열할 수 있다.",
        3: "cvs 파일을 표로 정리하고 범죄율을 데이터에 추가하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "오픈 라이브러리 pandas를 사용하여 cvs 파일을 표로 나타내는 데 어려움이 있다.",
        2: "오픈 라이브러리 pandas를 사용하여 cvs 파일을 표로 나타낼 수 있다.",
        3: "오픈 라이브러리 pandas를 능숙하게 사용하여 cvs 파일을 표로 나타낼 수 있다.",
      },
    },
    2: {
      decomposition: {
        1: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명할 수 있다.",
        3: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "종류별 범죄 데이터를 읽어올 때 어떤 작업이 반복되는지 인식하는 데 어려움이 있다.",
        2: "종류별 범죄 데이터를 읽어올 때 어떤 작업이 반복되는지 인식할 수 있다.",
        3: "종류별 범죄 데이터를 읽어올 때 어떤 작업이 반복되는지 인식하고 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "결과로 나온 그래프를 보고 가장 많이 상승한 범죄가 무엇인지 인식하는 데 어려움이 있다.",
        2: "결과로 나온 그래프를 보고 가장 많이 상승한 범죄가 무엇인지 인식할 수 있다.",
        3: "결과로 나온 그래프를 보고 가장 많이 상승한 범죄가 무엇인지 체계적으로 인식할 수 있다.",
      },
      algorithm: {
        1: "데이터를 꺾은선 그래프로 정리하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "데이터를 꺾은선 그래프로 정리하는 과정을 순서대로 나열할 수 있다",
        3: "데이터를 꺾은선 그래프로 정리하는 과정을 체계적인 순서대로 나열할 수 있다",
      },
      programming: {
        1: "오픈 라이브러리 plyplot을 사용하여 데이터를 꺾은선 그래프로 나타내는 데 어려움이 있다.",
        2: "오픈 라이브러리 plyplot을 사용하여 데이터를 꺾은선 그래프로 나타낼 수 있다.",
        3: "오픈 라이브러리 plyplot을 능숙하게 사용하여 데이터를 꺾은선 그래프로 나타낼 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명할 수 있다.",
        3: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "그래프를 보며 인구수가 높은 지역에서는 점이 어떻게 나타나는지 설명하는 데 어려움이 있다.",
        2: "그래프를 보며 인구수가 높은 지역에서는 점이 어떻게 나타나는지 설명할 수 있다.",
        3: "그래프를 보며 인구수가 높은 지역에서는 점이 어떻게 나타나는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "결과로 나온 그래프를 보고 밤과 낮의 인구수가 모두 많은 지역이 어디인지 인식하는 데 어려움이 있다.",
        2: "결과로 나온 그래프를 보고 밤과 낮의 인구수가 모두 많은 지역이 어디인지 인식할 수 있다.",
        3: "결과로 나온 그래프를 보고 밤과 낮의 인구수가 모두 많은 지역이 어디인지 인식하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "데이터를 산점도 그래프로 정리하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "데이터를 산점도 그래프로 정리하는 과정을 순서대로 나열할 수 있다",
        3: "데이터를 산점도 그래프로 정리하는 과정을 체계적인 순서대로 나열할 수 있다",
      },
      programming: {
        1: "오픈 라이브러리 plyplot을 사용하여 데이터를 산점도 그래프로 나타내는 데 어려움이 있다.",
        2: "오픈 라이브러리 plyplot을 사용하여 데이터를 산점도 그래프로 나타낼 수 있다.",
        3: "오픈 라이브러리 plyplot을 능숙하게 사용하여 데이터를 산점도 그래프로 나타낼 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명할 수 있다.",
        3: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "완성된 그래프를 보며 경찰이 담당하는 범위에 따라 원의 크기가 어떻게 달라지는지 설명하는 데 어려움이 있다.",
        2: "완성된 그래프를 보며 경찰이 담당하는 범위에 따라 원의 크기가 어떻게 달라지는지 설명할 수 있다.",
        3: "완성된 그래프를 보며 경찰이 담당하는 범위에 따라 원의 크기가 어떻게 달라지는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "결과로 나온 그래프를 보고 경찰이 담당하는 범위에 포함되지 못한 구역이 어디인지 인식하는 데 어려움이 있다.",
        2: "결과로 나온 그래프를 보고 경찰이 담당하는 범위에 포함되지 못한 구역이 어디인지 인식할 수 있다.",
        3: "결과로 나온 그래프를 보고 경찰이 담당하는 범위에 포함되지 못한 구역이 어디인지 인식하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "산점도 그래프에 다양한 데이터를 반영하는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "산점도 그래프에 다양한 데이터를 반영하는 과정을 순서대로 나열할 수 있다.",
        3: "산점도 그래프에 다양한 데이터를 반영하는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "오픈 라이브러리 plyplot을 사용하여 다양한 데이터를 산점도 그래프에 반영하는 데 어려움이 있다.",
        2: "오픈 라이브러리 plyplot을 사용하여 다양한 데이터를 산점도 그래프에 반영할 수 있다.",
        3: "오픈 라이브러리 plyplot을 능숙하게 사용하여 다양한 데이터를 산점도 그래프에 반영할 수 있다.",
      },
    },
  },
  12: {
    1: {
      decomposition: {
        1: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명할 수 있다.",
        3: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "선형 회귀 모델의 예시를 보고 상관관계에 따라 직선의 기울기가 어떻게 되는지 설명하는 데 어려움이 있다.",
        2: "선형 회귀 모델의 예시를 보고 상관관계에 따라 직선의 기울기가 어떻게 되는지 설명할 수 있다.",
        3: "선형 회귀 모델의 예시를 보고 상관관계에 따라 직선의 기울기가 어떻게 되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "선형 회귀 모델로 만든 직선의 기울기를 보고 등장인물 중 누구의 의견이 옳았는지 특정하는 데 어려움이 있다.",
        2: "선형 회귀 모델로 만든 직선의 기울기를 보고 등장인물 중 누구의 의견이 옳았는지 특정할 수 있다.",
        3: "선형 회귀 모델로 만든 직선의 기울기를 보고 등장인물 중 누구의 의견이 옳았는지 체계적인 근거를 대어 특정할 수 있다.",
      },
      algorithm: {
        1: "선형 회귀 모델을 만드는 과정을 순서대로 나열하는 데 어려움이 있다.",
        2: "선형 회귀 모델을 만드는 과정을 순서대로 나열할 수 있다.",
        3: "선형 회귀 모델을 만드는 과정을 체계적인 순서대로 나열할 수 있다.",
      },
      programming: {
        1: "주어진 코드를 활용하여 오차함수와 경사 하강법을 사용한 선형 회귀 모델을 만드는 데 어려움이 있다.",
        2: "주어진 코드를 활용하여 오차함수와 경사 하강법을 사용한 선형 회귀 모델을 만들 수 있다. ",
        3: "주어진 코드를 활용하여 오차함수와 경사 하강법을 사용한 선형 회귀 모델을 능숙하게 만들 수 있다. ",
      },
    },
    2: {
      decomposition: {
        1: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명할 수 있다.",
        3: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "KNN 클러스터링의 예시를 보고 나누어진 그룹별로 어떤 특징을 가지고 있을지 설명하는 데 어려움이 있다.",
        2: "KNN 클러스터링의 예시를 보고 나누어진 그룹별로 어떤 특징을 가지고 있을지 설명할 수 있다.",
        3: "KNN 클러스터링의 예시를 보고 나누어진 그룹별로 어떤 특징을 가지고 있을지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "KNN 클러스터링에서 점 사이의 거리와 데이터의 유사성을 연결하여 이해하는 데 어려움이 있다.",
        2: "KNN 클러스터링에서 점 사이의 거리와 데이터의 유사성을 연결하여 이해할 수 있다.",
        3: "KNN 클러스터링에서 점 사이의 거리와 데이터의 유사성을 연결하여 이해하고 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "KNN 클러스터링의 기본 작동 원리를 설명하는 데 어려움이 있다.",
        2: "KNN 클러스터링의 기본 작동 원리를 설명할 수 있다.",
        3: "KNN 클러스터링의 기본 작동 원리를 체계적으로 설명할 수 있다.",
      },
      programming: {
        1: "주어진 코드를 활용하여 KNN 클러스터링을 구현하는 데 어려움이 있다.",
        2: "주어진 코드를 활용하여 KNN 클러스터링을 구현할 수 있다.",
        3: "주어진 코드를 활용하여 KNN 클러스터링을 능숙하게 구현할 수 있다.",
      },
    },
    3: {
      decomposition: {
        1: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명하는 데 어려움이 있다.",
        2: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 설명할 수 있다.",
        3: "csv 파일로 주어진 데이터를 보고 어떤 요소로 이루어져 있는지 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "다른 기준을 사용하였을 때 중심점이 어떻게 되는지 설명하는 데 어려움이 있다.",
        2: "다른 기준을 사용하였을 때 중심점이 어떻게 되는지 설명할 수 있다.",
        3: "다른 기준을 사용하였을 때 중심점이 어떻게 되는지 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "비지도 학습과 지난 차시에 배운 지도 학습을 비교하여 설명하는 데 어려움이 있다.",
        2: "비지도 학습과 지난 차시에 배운 지도 학습을 비교하여 설명할 수 있다.",
        3: "비지도 학습과 지난 차시에 배운 지도 학습을 비교하여 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "K-means 클러스터링의 기본 작동 원리를 설명하는 데 어려움이 있다.",
        2: "K-means 클러스터링의 기본 작동 원리를 설명할 수 있다.",
        3: "K-means 클러스터링의 기본 작동 원리를 체계적으로 설명할 수 있다.",
      },
      programming: {
        1: "주어진 코드를 활용하여 K-means 클러스터링을 구현하는 데 어려움이 있다.",
        2: "주어진 코드를 활용하여 K-means 클러스터링을 구현할 수 있다.",
        3: "주어진 코드를 활용하여 K-means 클러스터링을 능숙하게 구현할 수 있다.",
      },
    },
    4: {
      decomposition: {
        1: "인공지능에게 인간의 감정을 구분하도록 만들 방법을 작은 문제로 나누어 설명하는 데 어려움이 있다.",
        2: "인공지능에게 인간의 감정을 구분하도록 만들 방법을 작은 문제로 나누어 설명할 수 있다.",
        3: "인공지능에게 인간의 감정을 구분하도록 만들 방법을 작은 문제로 나누어 체계적으로 설명할 수 있다.",
      },
      pattern: {
        1: "감정 인식 모델에 입력한 단어가 어떤 형태의 데이터로(ex:긍정 00%, 부정 00%) 출력될지 예상하는 데 어려움이 있다.",
        2: "감정 인식 모델에 입력한 단어가 어떤 형태의 데이터로(ex:긍정 00%, 부정 00%) 출력될지 예상할 수 있다.",
        3: "감정 인식 모델에 입력한 단어가 어떤 형태의 데이터로(ex:긍정 00%, 부정 00%) 출력될지 예상하고 근거를 들어 체계적으로 설명할 수 있다.",
      },
      abstraction: {
        1: "신경망을 통한 인공지능 학습이 무엇인지 설명하는 데 어려움이 있다.",
        2: "신경망을 통한 인공지능 학습이 무엇인지 설명할 수 있다.",
        3: "체신경망을 통한 인공지능 학습이 무엇인지 체계적으로 설명할 수 있다.",
      },
      algorithm: {
        1: "신경망을 통한 인공지능 학습이 어떤 과정으로 진행되는지 대략적으로 설명하는 데 어려움이 있다.",
        2: "신경망을 통한 인공지능 학습이 어떤 과정으로 진행되는지 대략적으로 설명할 수 있다.",
        3: "신경망을 통한 인공지능 학습이 어떤 과정으로 진행되는지 체계적으로 설명할 수 있다.",
      },
      programming: {
        1: "주어진 코드를 활용하여 기초 머신 러닝을 구현하는 데 어려움이 있다.",
        2: "주어진 코드를 활용하여 기초 머신 러닝을 구현할 수 있다.",
        3: "주어진 코드를 활용하여 기초 머신 러닝을 능숙하게 구현할 수 있다.",
      },
    },
  },
};
